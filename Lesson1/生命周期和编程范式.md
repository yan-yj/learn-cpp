# 生命周期和编程范式

## 编码

遵循语言规范和设计文档

## 预处理

预处理是C/C++独有的阶段，其目的是实现文字替换，常用的预处理指令有：#include、#define、#if，由预处理器执行  
预处理阶段编程的操作目标是“源码”，用各种指令控制预处理器，把源码改造成另外一种形式。以#开头，不属于C++语言，走的是预处理器，不受C++语法约束。需要注意的是，#要顶格写，#后面可以有若干空格。  
包含文件（#include），并非只是包含头文件，可以包含任意文件。例如代码中某些定义部分过长，且对逻辑没有太多影响，可以将其单独写到其他文件，然后在需要使用的地方包含进来，从而节省空间，简化代码。  
宏定义（#define/#undef），用来定义源码级别的文本替换，常用来定义常量/变量、实现函数功能、为类型起别名（typedef）。宏没有作用域概念，全局生效，使用完之后尽快取消（#undef）。

```cpp
#define CUBE(a) (a)*(a)*(a)

cout << CUBE(10) << endl;

#undef CUBE
```

使用预处理指令可以实现防卫式声明：  

```cpp
#ifndef _XXX_H_INCLUDE_
#define _XXX_H_INCLUDE_
...
#endif 
```

## 编译链接

静态检查、生成目标码、链接，由编译器执行  
输入C++源码，输出二进制可执行文件（汇编文件、动态库、静态库）  
属性[[xx]]，相当于编译阶段的“标签”，用来标记变量、函数或者类，让编译器发出或者不发出警告，还能指定代码的优化方式。  
静态断言static_assert()，类似assert()，可以根据表达式为假就报错。不同的是assert()是个宏，经过预处理后最终在运行期执行，static_assert()在编译期生效，因此也要注意它判断的表达式必须是编译期可见的，运行期的变量、指针、内存等无法使用静态断言。

## 运行

“静态的程序”被载入内存，由CPU逐条执行

## 编程范式

**C++支持五种范式**  
**面向过程：** 其核心思想是命令，按照顺序执行语句、子程序（函数），把任务分解为若干个步骤去执行，最终达成目标。  
**面向对象：** 其核心思想是“抽象”和“封装”，倡导将任务分解成一些高内聚、低耦合的对象，这些对象相互通信协作完成任务。强调对象之间的关系和接口，而非具体步骤。  
**泛型编程：** 其核心思想是“一切皆为类型（参数化类型他、类型擦除）”，使用模板而非继承的方式来复用代码，运行效率高，代码简洁。  
**模板元编程：** 其核心思想是“类型运算”，操作的数据是编译时可见的类型，代码只能由编译器执行，而不能被运行时的CPU执行。  
**函数式编程：** 其核心思想是“一切皆可调用”，通过一系列或者连续嵌套的函数实现对数据的处理。所谓的函数式不是C++中写成函数的子程序，而是数学意义上、无副作用的函数。  

## 命名规范

```cpp {line-numbers}
#define MAX_PATH_LEN 256                // 常量，全大写

int g_sys_flag;                         // 全局变量，加g_前缀

namespace linux_sys {                   // 命名空间，全小写  
    void get_rlimit_core();             // 函数名，全小写
}

class FilePath final                    // 类名，首字母大写
{
public:
    void set_path(const string& str);   // 函数名，全小写
private:
    string m_path;                      // 成员变量，m_前缀
    int    m_level;                     // 成员变量，m_前缀
}
```
